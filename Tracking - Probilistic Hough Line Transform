
################################################################################
######################### Lane Detection and Determination #####################
################################################################################


import numpy as np
import cv2

cap = cv2.VideoCapture('pa0001.MP4')
fourcc = cv2.VideoWriter_fourcc(*'XVID')

while True:
    _, frame = cap.read()

    roi1 = frame[90:280,5:355]
    roi2 = frame[90:280,375:725]

    
    grey1 = cv2.cvtColor(roi1, cv2.COLOR_BGR2GRAY)
##    grey2 = cv2.cvtColor(roi2, cv2.COLOR_BGR2GRAY)

##Color Filtering        

    lower = np.array([200])
    upper = np.array([255])

    mask1 = cv2.inRange(grey1, lower, upper)
##    mask2 = cv2.inRange(grey2, lower, upper)

    res1 = cv2.bitwise_and(grey1, grey1, mask = mask1)
##    res2 = cv2.bitwise_and(grey2, grey2, mask = mask2)

## Edge Detection

    edge1 = cv2.Canny(res1, 10, 10, apertureSize = 3)
    edge2 = cv2.Canny(res2, 10, 10, apertureSize = 3)
    
## Probablistic Hough Line Transform

## First Camera (Front Left)
    minLineLength = 20
    maxLineGap = 10
    font = cv2.FONT_HERSHEY_SIMPLEX

    lines = cv2.HoughLinesP(edge1,1,np.pi/180,10,minLineLength,maxLineGap)
    points = [[]]
    for i in range(0, len(lines)):
        for x1,y1,x2,y2 in lines[i]:            
            points[0].append((x1, y1, x2, y2))            
            cv2.line(roi1,(x1,y1),(x2,y2),(0,0,255),5)
            alpha = math.degrees(math.atan((y1-y2)/(x1-x2)))
            if 50 < x1&x2 < 100:
                X1 = (x1+x2)/2
            elif 280 < x1&x2 < 300:
                X2 = (x1+x2)/2
            else:
                X3 = (x1+x2)/2
                
##        c1 = (x11 + x12)/2
##        if c1 <= -100:
##            cv2.putText(frame, 'Lane 2', (20,250), font, 1.5, (200, 0,50), 5, cv2.LINE_AA)
##        else:
##            cv2.putText(frame, 'Lane 1', (20,250), font, 1.5, (200, 0,50), 5, cv2.LINE_AA)
        
####Second Camera (Front Rightt)
        
##    lines2 = cv2.HoughLinesP(edge2,1,np.pi/180,10,minLineLength,maxLineGap)
##   points = [[]]
##    for j in range(0, len(lines2)):
##        for x12,y12,x22,y22 in lines[j]:            
##            points[0].append((x12, y12, x22, y22))            
##            cv2.line(roi2,(x12,y12),(x22,y22),(0,0,255),5)
##            alpha2 = math.degrees(math.atan((y12-y22)/(x12-x22)))
##            if 50 < x12&x22 < 100:
##                X12 = (x12+x22)/2
##            elif 280 < x12&x22 < 300:
##                X22 = (x12+x22)/2
##            else:
##                X32 = (x12+x22)/2

        
##        c = (x1 + x2)/2
##        if c <= -100:
##            cv2.putText(frame, 'Lane 2', (20,250), font, 1.5, (200, 0,50), 5, cv2.LINE_AA)
##        else:
##            cv2.putText(frame, 'Lane 1', (20,250), font, 1.5, (200, 0,50), 5, cv2.LINE_AA)
                
        

    cv2.imshow('frame', frame)
    cv2.imshow('result', res1)
    cv2.imshow('Edges1', edge1)
##    cv2.imshow('Edges2', edge2)
##    cv2.imshow('Erosion', erosion)
##    cv2.imshow('Dilation', dilation)

    k = cv2.waitKey(1) & 0xFF
    if  k == 27:
         break

cap.release()
cv2.destroyAllWindows()
